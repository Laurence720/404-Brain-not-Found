<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>InvestMate</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/marked@9.1.6/marked.min.js"></script>
  <style>
    :root {
      --bg: #0f1115;
      --panel: #0f1217;
      --muted: #9aa3ae;
      --text: #e6e8eb;
      --brand: #1f2937;
      --brand-2: #2b313a;
      --ok: #16a34a;
      --err: #ef4444;
      --radius: 16px;
      --shadow-1: 0 12px 32px #00000066, 0 2px 8px #00000066;
      --border: #232833;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 80% -20%, #2a2f3a80, transparent 60%),
                  linear-gradient(140deg, #0b0e13 0%, #12161c 60%, #0b0e13 100%);
      background-size: 200% 200%, 100% 100%;
      animation: bg-pan 18s linear infinite;
    }
    /* Subtle grain */
    body::before { content: ""; position: fixed; inset: 0; pointer-events: none; z-index: 0;
      background-image: radial-gradient(#ffffff12 0.5px, transparent 0.5px);
      background-size: 2px 2px; opacity: .07; mix-blend-mode: soft-light; }

    .container { position: relative; max-width: 960px; margin: 0 auto; padding: 32px 24px 40px; z-index: 1; }
    header { display:flex; align-items:center; justify-content:space-between; margin-bottom: 20px; animation: fadeUp .6s both; }
    .title { font-weight: 800; letter-spacing: .2px; font-size: 26px; color: var(--text); }
    .badge { font-size: 13px; color: #e5e7eb; background: linear-gradient(120deg, #1c2027, #242a33, #1c2027);
             padding: 6px 14px; border-radius: 999px; border: 1px solid var(--border);
             background-size: 220% 100%; animation: shine 6s linear infinite; }

    .card { background: linear-gradient(180deg, #131821cc, #0f141bcc);
            border: 1px solid var(--border); border-radius: var(--radius);
            box-shadow: var(--shadow-1); overflow: hidden; backdrop-filter: blur(8px);
            transform-style: preserve-3d; will-change: transform, box-shadow;
            transition: transform .18s cubic-bezier(.2,.8,.2,1), box-shadow .3s ease; animation: floatIn .7s .05s both; }
    .card:hover { box-shadow: 0 18px 48px #00000088, 0 6px 18px #00000066; }

    .toolbar { display:flex; gap:8px; padding: 16px; border-bottom: 1px solid var(--border);
               background: linear-gradient(180deg, #0f141bcc, #0b0f16cc); align-items: center; }
    .toolbar .input { flex:1; display:flex; gap: 8px; background: #0b0f16; border: 1px solid #1b2230; border-radius: 12px; padding: 10px 12px; }
    textarea { flex:1; resize: vertical; min-height: 72px; max-height: 240px; border: none; outline: none; background: transparent; color: var(--text); font: inherit; }

    .btn {
      position: relative; overflow: hidden; display:inline-flex; align-items:center; gap:8px; padding: 10px 16px;
      border-radius: 12px; border: 1px solid #202633; background: #121821; color: #e5e7eb; cursor: pointer; font-weight: 700;
      transition: transform .06s ease, box-shadow .15s ease, background .2s ease, border-color .2s ease;
      user-select: none; box-shadow: 0 2px 10px #00000066 inset, 0 1px 0 #222a36;
    }
    .btn:hover { background: #171e28; box-shadow: 0 4px 14px #00000099; }
    .btn:active { transform: translateY(1px) scale(.99); }
    .btn.primary { background: linear-gradient(120deg, #0f1720, #1a2230, #0f1720); border-color: #263042; color: #f9fafb;
                   background-size: 220% 100%; animation: shine 8s linear infinite; }
    .btn.ghost { background: #0d131a; }
    .btn:disabled { opacity: .6; cursor: not-allowed; }
    .btn:focus-visible { outline: 2px solid #64748b; outline-offset: 2px; }
    .btn .ripple { position: absolute; left: 0; top: 0; width: 24px; height: 24px; border-radius: 999px;
                   background: radial-gradient(circle, #ffffff 0%, #ffffff 40%, #ffffff00 60%);
                   transform: translate(-50%, -50%) scale(0); opacity: .35; animation: ripple .7s ease-out forwards; pointer-events: none; filter: blur(.5px); }

    .status { font-size: 13px; color: var(--muted); margin-left: 12px; display:flex; align-items:center; gap:8px; }
    #status::before { content:""; width:8px; height:8px; border-radius:999px; background:#10b981; box-shadow: 0 0 0 0 #10b98166; display:inline-block; animation: pulse 1.8s infinite; }

    .chat { padding: 16px; display:flex; flex-direction: column; gap: 16px; max-height: calc(100vh - 280px); overflow: auto; background: #0b0f16; }
    .chat { -webkit-mask-image: linear-gradient(to bottom, transparent 0, rgba(0,0,0,.7) 24px, #000 48px, #000 calc(100% - 24px), transparent 100%);
             mask-image: linear-gradient(to bottom, transparent 0, rgba(0,0,0,.7) 24px, #000 48px, #000 calc(100% - 24px), transparent 100%);
    }

    .msg { display:flex; gap: 14px; align-items: flex-start; }
    .bubble { padding: 16px 18px; border-radius: 16px; border: 1px solid #1d2532; background: linear-gradient(180deg, #121824, #0f141c);
              max-width: 80%; white-space: pre-wrap; line-height: 1.75; box-shadow: 0 6px 22px #00000066; animation: bubbleIn .35s ease-out both; }
    .me .bubble { background: linear-gradient(180deg, #141b27, #101620); border-color: #263042; }
    .ai .bubble { background: linear-gradient(180deg, #10161f, #0d131a); border-color: #202636; }
    .role { font-size: 11px; font-weight: 700; letter-spacing: .12em; color: #93a0b3; margin-bottom: 8px; text-transform: uppercase; }

    .row { display:flex; gap: 8px; align-items:center; }
    .grow { flex:1; }

    footer { margin-top: 16px; color: var(--muted); font-size: 12px; display:flex; justify-content: space-between; align-items: center; gap: 8px; flex-wrap: wrap; }
    code.inline { background: #0f141c; border: 1px solid #1b2230; padding: 2px 6px; border-radius: 6px; color: #a9b2bd; }

    /* streaming toggle as a pill switch */
    #toggle-stream { position: relative; display:inline-flex; align-items:center; gap:8px; padding: 6px 36px 6px 14px; border-radius: 999px;
                     border: 1px solid #1b2230; background: #0e141c; color: #c5cbd4; text-decoration: none; transition: background .2s ease, border-color .2s ease; }
    #toggle-stream:hover { background:#141b25; border-color:#253042; }
    #toggle-stream::after { content:""; position: absolute; right: 8px; width: 16px; height: 16px; border-radius: 50%; background: #9ca3af; box-shadow: inset 0 0 0 2px #0b0f16; transition: transform .25s ease, background .25s ease; }
    #toggle-stream[data-on="true"]::after { transform: translateX(-18px); background: #16a34a; }

    .spinner { width: 16px; height: 16px; border: 2px solid #2c3440; border-top-color: transparent; border-radius: 50%; animation: spin .8s linear infinite; }

    /* Decorative, blurred floating orbs */
    .fx-orbs { position: fixed; inset: 0; pointer-events: none; z-index: 0; overflow: hidden; }
    .fx-orbs .orb { position: absolute; border-radius: 999px; filter: blur(60px); opacity: .12; background: radial-gradient(circle at 30% 30%, #ffffff, #a3aab4 60%, transparent 70%); }
    .fx-orbs .o1 { width: 420px; height: 420px; left: -120px; top: -80px; animation: float 16s ease-in-out infinite; }
    .fx-orbs .o2 { width: 360px; height: 360px; right: -140px; top: 20vh; animation: float 20s ease-in-out -3s infinite; }
    .fx-orbs .o3 { width: 520px; height: 520px; left: 10vw; bottom: -200px; animation: float 22s ease-in-out -6s infinite; }

    @media (max-width: 640px) { .bubble { max-width: 100%; } }

    /* Animations */
    @keyframes spin { to { transform: rotate(360deg); } }
    @keyframes fadeUp { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: none; } }
    @keyframes floatIn { from { opacity: 0; transform: translateY(10px) scale(.98); } to { opacity: 1; transform: none; } }
    @keyframes bubbleIn { from { opacity: 0; transform: translateY(6px) scale(.98); } to { opacity: 1; transform: translateY(0) scale(1); } }
    @keyframes shine { 0% { background-position: 200% 0; } 100% { background-position: -200% 0; } }
    @keyframes bg-pan { 0% { background-position: 0% 0%; } 100% { background-position: 200% 0%; } }
    @keyframes pulse { 0% { box-shadow: 0 0 0 0 #10b98166; } 70% { box-shadow: 0 0 0 8px #10b98100; } 100% { box-shadow: 0 0 0 0 #10b98100; } }
    @keyframes float { 0%,100% { transform: translateY(0) translateX(0) scale(1); } 50% { transform: translateY(-14px) translateX(6px) scale(1.02); } }
    @keyframes ripple { to { transform: translate(-50%, -50%) scale(14); opacity: 0; } }

    /* Quiz Modal Styles */
    .quiz-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      backdrop-filter: blur(4px);
    }

    .quiz-modal.show {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .quiz-content {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 32px;
      max-width: 600px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-1);
    }

    .quiz-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }

    .quiz-title {
      font-size: 24px;
      font-weight: 700;
      color: var(--text);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .quiz-close {
      background: none;
      border: none;
      color: var(--muted);
      font-size: 24px;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s;
    }

    .quiz-close:hover {
      color: var(--text);
      background: var(--brand-2);
    }

    .quiz-progress {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
    }

    .quiz-progress-text {
      font-size: 14px;
      color: var(--muted);
    }

    .quiz-progress-bar {
      flex: 1;
      height: 4px;
      background: var(--brand-2);
      border-radius: 2px;
      margin: 0 16px;
      overflow: hidden;
    }

    .quiz-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #1d4ed8);
      transition: width 0.3s ease;
    }

    .quiz-score {
      font-size: 14px;
      color: var(--muted);
    }

    .quiz-question {
      margin-bottom: 24px;
    }

    .quiz-question-text {
      font-size: 18px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 20px;
      line-height: 1.5;
    }

    .quiz-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .quiz-option {
      padding: 16px;
      background: var(--brand-2);
      border: 2px solid var(--border);
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 16px;
    }

    .quiz-option:hover {
      background: #374151;
      border-color: #4b5563;
    }

    .quiz-option.selected {
      border-color: #3b82f6;
      background: #1e3a8a20;
    }

    .quiz-option.correct {
      border-color: var(--ok);
      background: #16a34a20;
      color: var(--ok);
    }

    .quiz-option.incorrect {
      border-color: var(--err);
      background: #ef444420;
      color: var(--err);
    }

    .quiz-result {
      margin-top: 20px;
      padding: 16px;
      border-radius: 8px;
      display: none;
    }

    .quiz-result.show {
      display: block;
    }

    .quiz-result.correct {
      background: #16a34a20;
      border: 1px solid var(--ok);
      color: var(--ok);
    }

    .quiz-result.incorrect {
      background: #ef444420;
      border: 1px solid var(--err);
      color: var(--err);
    }

    .quiz-explanation {
      margin-top: 16px;
      padding: 16px;
      background: #1a1d23;
      border: 1px solid #374151;
      border-radius: 8px;
      font-size: 14px;
      line-height: 1.5;
      color: #e5e7eb;
      font-weight: 500;
    }

    .result-title {
      font-weight: 600;
      margin-bottom: 8px;
    }

    .result-explanation {
      font-size: 14px;
      opacity: 0.9;
    }

    .quiz-buttons {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
    }

    .quiz-button {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .quiz-button.primary {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
    }

    .quiz-button.primary:hover {
      background: linear-gradient(135deg, #2563eb, #1e40af);
    }

    .quiz-button.secondary {
      background: var(--brand-2);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .quiz-button.secondary:hover {
      background: #374151;
    }

    .quiz-results {
      text-align: center;
    }

    .quiz-results h3 {
      font-size: 24px;
      margin-bottom: 16px;
      color: var(--text);
    }

    .quiz-results p {
      font-size: 16px;
      color: var(--muted);
      margin-bottom: 24px;
    }

    /* --- Center the chat panel width & layout --- */
    header, footer, .card { max-width: 900px; width: 100%; margin-left: auto; margin-right: auto; }
    .container { display: grid; justify-items: center; align-content: start; min-height: 100dvh; gap: 12px; animation: pageRise .9s 1.1s cubic-bezier(.2,.8,.2,1) both; }
    .card { margin-top: 2vh; margin-bottom: 3vh; }

    /* --- Flashier page intro overlay --- */
    .intro { position: fixed; inset: 0; z-index: 999; display:flex; align-items:center; justify-content:center; background:
      radial-gradient(60% 60% at 50% 50%, #1a2230, #0b0f16 60%, #000 100%); overflow:hidden; }
    .intro .logo { font-weight: 900; font-size: clamp(32px, 7vw, 64px); letter-spacing: .12em; text-transform: uppercase;
      color: #e6e8eb; text-shadow: 0 0 24px #9fb2c533, 0 0 64px #9fb2c522; animation: logoPop .9s ease-out; }
    .intro .burst { position:absolute; width: 160vmax; height: 160vmax; background:
      conic-gradient(from 0deg, #ffffff10, #bcc6d520, #ffffff10 60%, transparent 80%); filter: blur(14px);
      animation: spin 2.6s linear infinite; opacity: .6; }
    .intro .beam { position:absolute; left:-20vw; right:-20vw; height:2px; background: linear-gradient(90deg, transparent, #ffffff66, transparent);
      filter: blur(1px); mix-blend-mode: screen; animation: sweep 1.3s ease-in-out .1s infinite; }
    .intro .beam.b2 { animation-delay: .4s; opacity:.6; }
    .intro .ring { position:absolute; width: 20vmin; height: 20vmin; border: 2px solid #aab2be44; border-radius: 999px;
      animation: ringExpand 1.2s cubic-bezier(.2,.8,.2,1) .2s forwards; }
    .intro .ring.r2 { animation-delay: .45s; opacity: .7; }

    .intro.hide { animation: introFade 1.1s ease forwards; }

    /* Page rise (content reveal) */
    @keyframes pageRise { from { opacity: 0; transform: translateY(16px) scale(.98); filter: blur(4px); }
      to { opacity: 1; transform: none; filter: none; } }

    /* Intro sequences */
    @keyframes logoPop { 0% { transform: translateY(14px) scale(.92); opacity: 0; }
      60% { transform: translateY(-4px) scale(1.04); opacity: 1; }
      100% { transform: none; } }
    @keyframes introFade { to { opacity: 0; visibility: hidden; } }
    @keyframes sweep { 0% { transform: translateY(-40vh); opacity: 0; } 50% { opacity: 1; } 100% { transform: translateY(40vh); opacity: 0; } }
    @keyframes ringExpand { from { transform: scale(.2); opacity: .9; } to { transform: scale(12); opacity: 0; } }

    /* Quiz Modal Styles */
    .quiz-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }

    .quiz-modal.show {
      display: flex;
    }

    .quiz-container {
      background: linear-gradient(180deg, #131821cc, #0f141bcc);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow-1);
      backdrop-filter: blur(8px);
      max-width: 600px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
      animation: quizSlideIn 0.3s ease-out;
    }

    .quiz-header {
      padding: 20px 24px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(180deg, #0f141bcc, #0b0f16cc);
    }

    .quiz-title {
      font-size: 20px;
      font-weight: 700;
      color: var(--text);
      margin: 0 0 8px 0;
    }

    .quiz-term {
      font-size: 14px;
      color: var(--muted);
      margin: 0;
    }

    .quiz-content {
      padding: 24px;
    }

    .quiz-question {
      margin-bottom: 20px;
    }

    .question-text {
      font-size: 16px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .question-options {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .option-button {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      background: #0b0f16;
      border: 1px solid #1b2230;
      border-radius: 12px;
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 14px;
    }

    .option-button:hover {
      background: #121821;
      border-color: #263042;
    }

    .option-button.selected {
      background: #1a2230;
      border-color: #3b82f6;
      color: #60a5fa;
    }

    .option-button.correct {
      background: #0f1720;
      border-color: #16a34a;
      color: #22c55e;
    }

    .option-button.incorrect {
      background: #1f1415;
      border-color: #ef4444;
      color: #f87171;
    }

    .option-label {
      font-weight: 600;
      margin-right: 12px;
      min-width: 24px;
    }

    .quiz-actions {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
      margin-top: 24px;
      padding-top: 20px;
      border-top: 1px solid var(--border);
    }

    .quiz-result {
      background: #0f141c;
      border: 1px solid #1b2230;
      border-radius: 12px;
      padding: 16px;
      margin-top: 16px;
    }

    .result-title {
      font-size: 14px;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 8px;
    }

    .result-explanation {
      font-size: 14px;
      color: var(--muted);
      line-height: 1.5;
    }

    .quiz-progress {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      font-size: 14px;
      color: var(--muted);
    }

    .progress-bar {
      flex: 1;
      height: 4px;
      background: #1b2230;
      border-radius: 2px;
      margin: 0 12px;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3b82f6, #1d4ed8);
      border-radius: 2px;
      transition: width 0.3s ease;
    }

    @keyframes quizSlideIn {
      from {
        opacity: 0;
        transform: translateY(20px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }
  </style>
</head>
<body>
  <!-- Intro overlay -->
  <div id="intro" class="intro" aria-hidden="true">
    <div class="burst"></div>
    <div class="beam"></div>
    <div class="beam b2"></div>
    <span class="ring r1"></span>
    <span class="ring r2"></span>
    <div class="logo">InvestMate</div>
  </div>

  <div class="fx-orbs" aria-hidden="true">
    <span class="orb o1"></span>
    <span class="orb o2"></span>
    <span class="orb o3"></span>
  </div>

  <!-- Quiz Modal -->
  <div id="quizModal" class="quiz-modal">
    <div class="quiz-container">
      <div class="quiz-header">
        <h2 class="quiz-title">📚 Finance Quiz</h2>
        <p class="quiz-term" id="quizTerm">Topic: Portfolio</p>
      </div>
      <div class="quiz-content">
        <div class="quiz-progress">
          <span id="quizProgress">Question 1 / 3</span>
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill" style="width: 33%"></div>
          </div>
          <span id="quizScore">Score: 0</span>
        </div>
        <div class="quiz-question" id="quizQuestion">
          <!-- Question content will be inserted here -->
        </div>
        <div class="quiz-explanation" id="quizExplanation" style="display: none;">
          <!-- Answer explanation will be inserted here -->
        </div>
        <div class="quiz-actions">
          <button id="quizSubmit" class="btn primary" disabled>Submit Answer</button>
          <button id="quizNext" class="btn ghost" style="display: none;">Next Question</button>
          <button id="quizClose" class="btn ghost">Close</button>
        </div>
      </div>
    </div>
  </div>

  <div class="container">
    <header>
      <div class="row">
        <div class="badge">InvestMate</div>
        <div class="status" id="status">InvestMate is ready · ask away</div>
      </div>
      <div class="title">InvestMate · Your Wealth Copilot</div>
    </header>

    <section class="card" role="region" aria-label="Chat Panel">
      <div class="toolbar">
        <div class="input">
          <textarea id="prompt" placeholder="Ask InvestMate anything. Press Ctrl/⌘ + Enter to send…"></textarea>
        </div>
        <button id="send" class="btn primary" title="Send (Ctrl/⌘+Enter)">Send</button>
        <button id="clear" class="btn ghost" title="Clear conversation">Clear</button>
      </div>
      <div id="chat" class="chat" aria-live="polite"></div>
    </section>

    <footer>
      <div>Endpoint <code class="inline">POST /api/chat</code> returns <code class="inline">{ output: string }</code>.</div>
      <div><a href="#" id="toggle-stream" data-on="false" role="switch" aria-checked="false">Streaming: Off</a></div>
    </footer>
  </div>

  <script>
    // =================== Configuration (tweak as needed) ===================
    const API_URL = `${window.location.origin}/api/chat`;
    let STREAMING = false;                // Enable streaming if the backend supports SSE / fetch streams

    // =================== Lightweight state & DOM helpers ===================
    const chatEl = document.getElementById('chat');
    const promptEl = document.getElementById('prompt');
    const sendBtn = document.getElementById('send');
    const clearBtn = document.getElementById('clear');
    const statusEl = document.getElementById('status');
    const toggleStream = document.getElementById('toggle-stream');

    const cardEl = document.querySelector('.card');

    // Button ripple effect
    function createRipple(e) {
      const btn = e.currentTarget;
      const rect = btn.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      const rip = document.createElement('span');
      rip.className = 'ripple';
      rip.style.left = x + 'px';
      rip.style.top = y + 'px';
      btn.appendChild(rip);
      rip.addEventListener('animationend', () => rip.remove());
    }
    // Attach ripple to all buttons
    document.querySelectorAll('.btn').forEach(b => b.addEventListener('click', createRipple));

    // 3D tilt on the main card
    if (cardEl) {
      const resetTilt = () => { cardEl.style.transform = ''; };
      cardEl.addEventListener('mousemove', (e) => {
        const r = cardEl.getBoundingClientRect();
        const cx = r.left + r.width / 2;
        const cy = r.top + r.height / 2;
        const dx = (e.clientX - cx) / r.width;  // -0.5 .. 0.5
        const dy = (e.clientY - cy) / r.height; // -0.5 .. 0.5
        const rx = (dy) * 6;   // rotateX
        const ry = -(dx) * 8;  // rotateY
        cardEl.style.transform = `perspective(1000px) rotateX(${rx}deg) rotateY(${ry}deg) translateZ(6px)`;
      });
      cardEl.addEventListener('mouseleave', resetTilt);
    }

    const state = { messages: [] };
    
    // Quiz state
    let currentQuiz = null;
    let currentQuestionIndex = 0;
    let quizScore = 0;
    let userAnswers = [];

    function appendMessage(role, content) {
      const wrap = document.createElement('div');
      wrap.className = `msg ${role}`;

      const bubble = document.createElement('div');
      bubble.className = 'bubble';
      bubble.classList.add('pop');

      const roleEl = document.createElement('div');
      roleEl.className = 'role';
      roleEl.textContent = role === 'me' ? 'You' : 'InvestMate';

      const contentEl = document.createElement('div');

      bubble.appendChild(roleEl);
      bubble.appendChild(contentEl);
      wrap.appendChild(bubble);
      chatEl.appendChild(wrap);
      chatEl.scrollTop = chatEl.scrollHeight;

      // Check if this message contains a quiz card
      if (role === 'ai') {
        console.log('appendMessage: Processing AI content for quiz detection.');
        console.log('appendMessage: Raw content:', content.substring(0, 200) + '...'); // Log first 200 chars
        console.log('appendMessage: Full content length:', content.length);
        console.log('appendMessage: Content contains "Quiz":', content.includes('Quiz'));
        console.log('appendMessage: Content contains "Concept Card":', content.includes('Concept Card'));
        const quizCard = parseQuizFromMessage(content);
        console.log('appendMessage: Quiz card found:', quizCard); // Log the result of parseQuizFromMessage
        if (quizCard) {
          // Re-render the content without the quiz section
          let modifiedContent = content;
          
          // Remove quiz sections in different formats
          modifiedContent = modifiedContent.replace(/### Quiz[\s\S]*$/m, '');
          modifiedContent = modifiedContent.replace(/```json[\s\S]*?```/g, '');
          modifiedContent = modifiedContent.replace(/\{[\s\S]*"card"[\s\S]*\}/g, '');
          modifiedContent = modifiedContent.replace(/\[\s*\{[\s\S]*?\}\s*\]/g, '');
          
          contentEl.innerHTML = marked.parse(modifiedContent);
          
          // Add a button to start the quiz
          const quizButton = document.createElement('button');
          quizButton.className = 'btn primary';
          quizButton.style.marginTop = '12px';
          quizButton.textContent = '📚 Start Quiz';
          quizButton.addEventListener('click', () => showQuiz(quizCard));
          bubble.appendChild(quizButton);
        } else {
          // No quiz card, just display the content normally
          contentEl.innerHTML = marked.parse(content);
        }
      } else {
        // User message, display as text
        contentEl.textContent = content;
      }
    }

    function setLoading(loading) {
      sendBtn.disabled = loading;
      statusEl.innerHTML = loading ? '<span class="row"><span class="spinner"></span> InvestMate is thinking…</span>' : 'InvestMate is ready · ask away';
    }

    // Quiz functions

    function parseQuizFromMessage(content) {
      try {
        console.log('Parsing quiz from content:', content);
        console.log('Content type:', typeof content);
        console.log('Content length:', content.length);
        console.log('Content starts with:', content.substring(0, 100));
        
        // First try to parse the entire content as JSON (for backend responses)
        try {
          const fullData = JSON.parse(content);
          console.log('Parsed full content as JSON:', fullData);
          if (fullData.card && fullData.card.questions && fullData.card.questions.length > 0) {
            console.log('Found valid quiz card in full content:', fullData.card);
            // Ensure each question has clean data
            const cleanQuestions = fullData.card.questions.map(q => {
              const cleanQ = {
                type: q.type,
                question: q.question,
                answer: q.answer,
                explanation: q.explanation || 'No explanation available'
              };
              // Only add options for single choice questions
              if (q.type === 'single' && q.options) {
                cleanQ.options = q.options;
              }
              return cleanQ;
            });
            return {
              ...fullData.card,
              questions: cleanQuestions
            };
          }
        } catch (e) {
          console.log('Full content is not JSON, trying other formats');
        }
        
        // Try to find JSON array format (LLM might return array directly)
        const arrayMatch = content.match(/```json\s*(\[[\s\S]*?\])\s*```/);
        if (arrayMatch) {
          try {
            const questionsArray = JSON.parse(arrayMatch[1]);
            console.log('Found JSON array:', questionsArray);
            if (Array.isArray(questionsArray) && questionsArray.length > 0) {
              // Fix answer format and convert array to card format
              const fixedQuestions = questionsArray.map(q => {
                const fixedQ = { ...q };
                
                // Fix single choice answers (A, B, C, D -> 0, 1, 2, 3)
                if (fixedQ.type === 'single' && typeof fixedQ.answer === 'string') {
                  if (fixedQ.answer.match(/^[A-D]$/)) {
                    fixedQ.answer = fixedQ.answer.charCodeAt(0) - 65;
                  }
                }
                
                // Fix bool answers (string -> boolean)
                if (fixedQ.type === 'bool' && typeof fixedQ.answer === 'string') {
                  fixedQ.answer = fixedQ.answer.toLowerCase() === 'true';
                }
                
                // Ensure explanation field exists
                if (!fixedQ.explanation) {
                  fixedQ.explanation = 'No explanation available';
                }
                
                return fixedQ;
              });
              
              // Extract term from content if possible
              let extractedTerm = 'quiz';
              const termMatch = content.match(/### Concept Card[\s\S]*?\*\*Term:\*\*\s*([^\n]+)/);
              if (termMatch) {
                extractedTerm = termMatch[1].trim();
              }
              
              const card = {
                term: extractedTerm,
                questions: fixedQuestions,
                citations: [],
                lang: 'zh'
              };
              console.log('Converted array to card:', card);
              return card;
            }
          } catch (e) {
            console.log('Array parsing failed:', e);
          }
        }
        
        // Try to find raw JSON array without code blocks (from backend)
        const rawArrayMatch = content.match(/\[\s*\{[\s\S]*?\}\s*\]/);
        if (rawArrayMatch) {
          try {
            const questionsArray = JSON.parse(rawArrayMatch[0]);
            console.log('Found raw JSON array:', questionsArray);
            if (Array.isArray(questionsArray) && questionsArray.length > 0) {
              // Fix answer format and convert array to card format
              const fixedQuestions = questionsArray.map(q => {
                const fixedQ = { ...q };
                
                // Fix single choice answers (A, B, C, D -> 0, 1, 2, 3)
                if (fixedQ.type === 'single' && typeof fixedQ.answer === 'string') {
                  if (fixedQ.answer.match(/^[A-D]$/)) {
                    fixedQ.answer = fixedQ.answer.charCodeAt(0) - 65;
                  }
                }
                
                // Fix bool answers (string -> boolean)
                if (fixedQ.type === 'bool' && typeof fixedQ.answer === 'string') {
                  fixedQ.answer = fixedQ.answer.toLowerCase() === 'true';
                }
                
                // Ensure explanation field exists
                if (!fixedQ.explanation) {
                  fixedQ.explanation = 'No explanation available';
                }
                
                return fixedQ;
              });
              
              // Extract term from content if possible
              let extractedTerm = 'quiz';
              const termMatch = content.match(/### Concept Card[\s\S]*?\*\*Term:\*\*\s*([^\n]+)/);
              if (termMatch) {
                extractedTerm = termMatch[1].trim();
              }
              
              const card = {
                term: extractedTerm,
                questions: fixedQuestions,
                citations: [],
                lang: 'zh'
              };
              console.log('Converted raw array to card:', card);
              return card;
            }
          } catch (e) {
            console.log('Raw array parsing failed:', e);
          }
        }
        
        // Try to find JSON object that contains card with questions (more flexible approach)
        const jsonPatterns = [
          /\{[^{}]*"card"[^{}]*\{[^{}]*"questions"[^{}]*\[[^\]]*\][^{}]*\}[^{}]*\}/,
          /\{[\s\S]*"card"[\s\S]*\}/,
          /\{[\s\S]*"questions"[\s\S]*\}/
        ];
        
        for (const pattern of jsonPatterns) {
          const match = content.match(pattern);
          if (match) {
            try {
              const quizData = JSON.parse(match[0]);
              console.log('Found JSON with pattern:', pattern, quizData);
              
              if (quizData.card && quizData.card.questions && quizData.card.questions.length > 0) {
                console.log('Found valid quiz card:', quizData.card);
                // Clean the questions data
                const cleanQuestions = quizData.card.questions.map(q => {
                  const cleanQ = {
                    type: q.type,
                    question: q.question,
                    answer: q.answer,
                    explanation: q.explanation || 'No explanation available'
                  };
                  // Only add options for single choice questions
                  if (q.type === 'single' && q.options) {
                    cleanQ.options = q.options;
                  }
                  return cleanQ;
                });
                return {
                  ...quizData.card,
                  questions: cleanQuestions
                };
              } else if (quizData.questions && quizData.questions.length > 0) {
                // Convert to card format
                const cleanQuestions = quizData.questions.map(q => {
                  const cleanQ = {
                    type: q.type,
                    question: q.question,
                    answer: q.answer,
                    explanation: q.explanation || 'No explanation available'
                  };
                  // Only add options for single choice questions
                  if (q.type === 'single' && q.options) {
                    cleanQ.options = q.options;
                  }
                  return cleanQ;
                });
                const card = {
                  term: quizData.term || 'quiz',
                  questions: cleanQuestions,
                  citations: quizData.citations || [],
                  lang: quizData.lang || 'en'
                };
                console.log('Converted to card format:', card);
                return card;
              }
            } catch (e) {
              console.log('JSON parsing failed for pattern:', pattern, e);
            }
          }
        }
        
        // Try to find JSON with card field using a more robust regex
        const cardMatch = content.match(/\{[^{}]*"card"[^{}]*\{[^{}]*"questions"[^{}]*\[[^\]]*\][^{}]*\}[^{}]*\}/);
        if (cardMatch) {
          try {
            const quizData = JSON.parse(cardMatch[0]);
            console.log('Found card JSON:', quizData);
            if (quizData.card && quizData.card.questions && quizData.card.questions.length > 0) {
              console.log('Found valid quiz card:', quizData.card);
              // Clean the questions data
              const cleanQuestions = quizData.card.questions.map(q => {
                const cleanQ = {
                  type: q.type,
                  question: q.question,
                  answer: q.answer,
                  explanation: q.explanation || 'No explanation available'
                };
                // Only add options for single choice questions
                if (q.type === 'single' && q.options) {
                  cleanQ.options = q.options;
                }
                return cleanQ;
              });
              return {
                ...quizData.card,
                questions: cleanQuestions
              };
            }
          } catch (e) {
            console.log('Card JSON parsing failed:', e);
          }
        }
        
        // Try to find any JSON object that contains questions
        const questionsMatch = content.match(/\{[\s\S]*"questions"[\s\S]*\}/);
        if (questionsMatch) {
          try {
            const quizData = JSON.parse(questionsMatch[0]);
            console.log('Found JSON with questions:', quizData);
            if (quizData.questions && quizData.questions.length > 0) {
              // Convert to card format
              const cleanQuestions = quizData.questions.map(q => {
                const cleanQ = {
                  type: q.type,
                  question: q.question,
                  answer: q.answer,
                  explanation: q.explanation || 'No explanation available'
                };
                // Only add options for single choice questions
                if (q.type === 'single' && q.options) {
                  cleanQ.options = q.options;
                }
                return cleanQ;
              });
              const card = {
                term: quizData.term || 'quiz',
                questions: cleanQuestions,
                citations: quizData.citations || [],
                lang: quizData.lang || 'en'
              };
              console.log('Converted to card format:', card);
              return card;
            }
          } catch (e) {
            console.log('Questions JSON parsing failed:', e);
          }
        }
        
        // Try to find JSON format with code blocks
        const jsonMatch = content.match(/```json\s*(\{[\s\S]*?\})\s*```/);
        if (jsonMatch) {
          try {
            const quizData = JSON.parse(jsonMatch[1]);
            console.log('Parsed JSON data:', quizData);
            if (quizData.card && quizData.card.questions && quizData.card.questions.length > 0) {
              console.log('Found valid quiz card:', quizData.card);
              return quizData.card;
            }
          } catch (e) {
            console.log('JSON parsing failed, trying markdown format');
          }
        }
        

        // Try to parse markdown format - find all quiz sections
        const quizMatches = content.match(/### Quiz[\s\S]*?(?=### Quiz|### Concept Card|$)/g);
        if (quizMatches && quizMatches.length > 0) {
          // If multiple quizzes, try to find the most relevant one
          let selectedQuiz = quizMatches[0]; // default to first
          
          // Look for quiz that matches the user's question better
          for (const quiz of quizMatches) {
            // Extract the term from this quiz
            const quizTermMatch = quiz.match(/\*\*Term:\*\*\s*(.+?)(?:\n|$)/);
            if (quizTermMatch) {
              const quizTerm = quizTermMatch[1].trim().toLowerCase();
              console.log('Found quiz with term:', quizTerm);
              
              // Check if this quiz has questions about the specific topic
              // Look for the most specific term that's not generic
              if (quizTerm === 'what is bond' || quizTerm === 'what is stock' || quizTerm === 'what is portfolio') {
                selectedQuiz = quiz;
                console.log('Selected quiz with specific term:', quizTerm);
                break; // Stop at first specific match
              }
            }
          }
          
          // If no specific quiz found, try to find the last (most recent) quiz
          if (selectedQuiz === quizMatches[0] && quizMatches.length > 1) {
            selectedQuiz = quizMatches[quizMatches.length - 1];
            const lastQuizTermMatch = selectedQuiz.match(/\*\*Term:\*\*\s*(.+?)(?:\n|$)/);
            if (lastQuizTermMatch) {
              console.log('Selected last quiz with term:', lastQuizTermMatch[1].trim());
            }
          }
          
          console.log('Final selected quiz term:', selectedQuiz.match(/\*\*Term:\*\*\s*(.+?)(?:\n|$)/)?.[1]?.trim());
          
          const quizText = selectedQuiz;
          const questions = [];
          
          // Extract term from Concept Card if available
          let term = 'quiz';
          const termMatch = content.match(/\*\*Term:\*\*\s*(.+?)(?:\n|$)/);
          if (termMatch) {
            term = termMatch[1].trim();
          }
          
          // Split by question numbers
          const questionMatches = quizText.match(/\d+\.\s*([^?]+\?)[\s\S]*?(?=\d+\.|$)/g);
          if (questionMatches) {
            questionMatches.forEach((qText, index) => {
              const question = {};
              
              // Extract question text - try multiple patterns
              let questionText = '';
              
              // Pattern 1: Standard question format
              const questionMatch = qText.match(/\d+\.\s*([^?]+\?)/);
              if (questionMatch) {
                questionText = questionMatch[1].trim();
              }
              
              // Pattern 2: True/False format
              if (!questionText) {
                const boolMatch = qText.match(/\d+\.\s*True\/False:\s*([^?]+\?)/);
                if (boolMatch) {
                  questionText = boolMatch[1].trim();
                }
              }
              
              // Pattern 3: Any text ending with ?
              if (!questionText) {
                const anyMatch = qText.match(/\d+\.\s*([^?]+\?)/);
                if (anyMatch) {
                  questionText = anyMatch[1].trim();
                }
              }
              
              // Pattern 4: Look for any sentence ending with ?
              if (!questionText) {
                const sentenceMatch = qText.match(/([^?]+\?)/);
                if (sentenceMatch) {
                  questionText = sentenceMatch[1].trim();
                }
              }
              
              // If still no question text, create a generic one
              if (!questionText) {
                questionText = `Question ${index + 1}`;
              }
              
              question.question = questionText;
              
              // Check if it's True/False
              if (qText.includes('True/False:') || qText.includes('True or False:') || 
                  qText.includes('Answer: True') || qText.includes('Answer: False') ||
                  qText.match(/Is it true that|Is it false that|Are.*true|Are.*false/i)) {
                question.type = 'bool';
                // Don't set options for bool questions
                
                // Extract answer
                const answerMatch = qText.match(/Answer:\s*(True|False)/i);
                if (answerMatch) {
                  question.answer = answerMatch[1].toLowerCase() === 'true';
                } else {
                  question.answer = true; // default
                }
              } else {
                // Multiple choice
                question.type = 'single';
                
                // Extract options
                const optionsMatch = qText.match(/Options:\s*([\s\S]*?)Answer:/);
                if (optionsMatch) {
                  const optionsText = optionsMatch[1];
                  const optionParts = optionsText.split(';');
                  const options = optionParts.map(part => {
                    const match = part.match(/[A-D]\.\s*(.+)/);
                    if (match) {
                      return match[1].trim();
                    }
                    return part.trim();
                  }).filter(opt => opt.length > 0);
                  question.options = options;
                } else {
                  // Try to extract options from the text directly
                  const optionMatches = qText.match(/[A-D]\.\s*[^A-D\n]+/g);
                  if (optionMatches && optionMatches.length >= 2) {
                    const options = optionMatches.map(opt => {
                      const match = opt.match(/[A-D]\.\s*(.+)/);
                      return match ? match[1].trim() : opt.trim();
                    });
                    question.options = options;
                  } else {
                    question.options = ['Option A', 'Option B', 'Option C', 'Option D'];
                  }
                }
                
                // Extract answer
                const answerMatch = qText.match(/Answer:\s*([A-D])/);
                if (answerMatch) {
                  question.answer = answerMatch[1].charCodeAt(0) - 65; // A=0, B=1, C=2, D=3
                } else {
                  question.answer = 0; // default
                }
              }
              
              // Extract explanation
              const explanationMatch = qText.match(/Why:\s*(.+?)(?:\n|$)/);
              if (explanationMatch) {
                question.explanation = explanationMatch[1].trim();
              } else {
                question.explanation = 'No explanation available';
              }
              
              if (question.question) {
                questions.push(question);
              }
            });
          }
          
          if (questions.length > 0) {
            return {
              term: term,
              questions: questions,
              citations: [],
              lang: 'zh'
            };
          }
        }
        
        return null;
      } catch (e) {
        console.error('Error parsing quiz:', e);
        return null;
      }
    }

    function showQuiz(quizCard) {
      console.log('Starting quiz with card:', quizCard);
      currentQuiz = quizCard;
      currentQuestionIndex = 0;
      quizScore = 0;
      
      document.getElementById('quizModal').classList.add('show');
      document.getElementById('quizTotal').textContent = quizCard.questions.length;
      document.getElementById('quizScore').textContent = '0';
      
      displayQuestion();
    }

    function closeQuiz() {
      document.getElementById('quizModal').classList.remove('show');
      currentQuiz = null;
      currentQuestionIndex = 0;
      quizScore = 0;
    }

    function displayQuestion() {
      if (!currentQuiz || currentQuestionIndex >= currentQuiz.questions.length) {
        showQuizResults();
        return;
      }
      
      const question = currentQuiz.questions[currentQuestionIndex];
      const questionEl = document.getElementById('quizQuestionText');
      const optionsEl = document.getElementById('quizOptions');
      const resultEl = document.getElementById('quizResult');
      const nextBtn = document.getElementById('quizNext');
      
      // Update progress
      document.getElementById('quizCurrent').textContent = currentQuestionIndex + 1;
      const progress = ((currentQuestionIndex + 1) / currentQuiz.questions.length) * 100;
      document.getElementById('quizProgressFill').style.width = progress + '%';
      
      // Clear previous state
      resultEl.classList.remove('show', 'correct', 'incorrect');
      nextBtn.style.display = 'none';
      
      // Set question text
      questionEl.textContent = question.question;
      
      // Create options
      optionsEl.innerHTML = '';
      question.options.forEach((option, index) => {
        const optionEl = document.createElement('div');
        optionEl.className = 'quiz-option';
        optionEl.textContent = `${String.fromCharCode(65 + index)}. ${option}`;
        optionEl.addEventListener('click', () => selectOption(index, question));
        optionsEl.appendChild(optionEl);
      });
    }

    function selectOption(selectedIndex, question) {
      const options = document.querySelectorAll('.quiz-option');
      const isCorrect = selectedIndex === question.answer;
      
      // Mark selected option
      options[selectedIndex].classList.add('selected');
      
      // Mark correct/incorrect
      options.forEach((option, index) => {
        option.style.pointerEvents = 'none';
        if (index === question.answer) {
          option.classList.add('correct');
        } else if (index === selectedIndex && !isCorrect) {
          option.classList.add('incorrect');
        }
      });
      
      // Update score
      if (isCorrect) {
        quizScore++;
        document.getElementById('quizScore').textContent = quizScore;
      }
      
      // Show result
      const resultEl = document.getElementById('quizResult');
      resultEl.classList.add('show', isCorrect ? 'correct' : 'incorrect');
      
      // Show explanation
      const explanationEl = document.getElementById('quizExplanation');
      if (explanationEl) {
        explanationEl.textContent = question.explanation || 'No explanation available';
        explanationEl.style.display = 'block';
      }
      
      // Debug: log question data
      console.log('Question data:', question);
      console.log('Explanation:', question.explanation);
      
      // Clear previous result content
      resultEl.innerHTML = '';
      const resultDiv = document.createElement('div');
      resultDiv.innerHTML = `
        <div class="result-title">${isCorrect ? '✅ Correct!' : '❌ Incorrect'}</div>
        <div class="result-explanation">${question.explanation || 'No explanation available'}</div>
      `;
      resultEl.appendChild(resultDiv);
      
      // Show next button
      const nextBtn = document.getElementById('quizNext');
      if (currentQuestionIndex < currentQuiz.questions.length - 1) {
        nextBtn.textContent = 'Next Question';
        nextBtn.style.display = 'inline-flex';
      } else {
        nextBtn.textContent = 'View Results';
        nextBtn.style.display = 'inline-flex';
      }
    }

    function nextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex < currentQuiz.questions.length) {
        displayQuestion();
      } else {
        showQuizResults();
      }
    }

    function showQuizResults() {
      const questionEl = document.getElementById('quizQuestion');
      const nextBtn = document.getElementById('quizNext');
      
      questionEl.innerHTML = `
        <div class="quiz-results">
          <h3>Quiz Complete!</h3>
          <p>You answered ${quizScore} of ${currentQuiz.questions.length} questions correctly</p>
          <p>Accuracy: ${Math.round((quizScore / currentQuiz.questions.length) * 100)}%</p>
        </div>
      `;
      
      nextBtn.style.display = 'none';
    }

    async function sendNonStreaming(payload) {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      return data.output ?? '';
    }

    async function sendStreaming(payload) {
      const res = await fetch(API_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'Accept': 'text/event-stream' },
        body: JSON.stringify({ ...payload, stream: true }),
      });
      if (!res.ok || !res.body) throw new Error(`HTTP ${res.status}`);

      const reader = res.body.getReader();
      const decoder = new TextDecoder();

      // Pre-populate the chat with an empty assistant bubble
      const wrap = document.createElement('div');
      wrap.className = 'msg ai';
      const bubble = document.createElement('div');
      bubble.className = 'bubble pop';
      const roleEl = document.createElement('div');
      roleEl.className = 'role';
      roleEl.textContent = 'InvestMate';
      const contentEl = document.createElement('div');
      contentEl.textContent = '';
      bubble.appendChild(roleEl);
      bubble.appendChild(contentEl);
      wrap.appendChild(bubble);
      chatEl.appendChild(wrap);

      let buffer = '';
      let fullText = '';
      while (true) {
        const { value, done } = await reader.read();
        if (done) break;
        buffer += decoder.decode(value, { stream: true });

        // Parse SSE payloads split by blank lines, with each line prefixed by `data:`
        const events = buffer.split("\n\n");
        buffer = events.pop() || "";
        for (const evt of events) {
          const lines = evt.split("\n");
          for (const line of lines) {
            if (line.startsWith("data:")) {
              const text = line.slice(5).trimStart();
              contentEl.textContent += text;
              fullText += text;
              chatEl.scrollTop = chatEl.scrollHeight;
            }
          }
        }
      }
      return fullText || contentEl.textContent;
    }

    async function handleSend() {
      const content = promptEl.value.trim();
      if (!content) return;

      appendMessage('me', content);
      promptEl.value = '';
      setLoading(true);

      const payload = { input: content, history: state.messages };
      try {
        if (STREAMING) {
          const output = await sendStreaming(payload);
          state.messages.push({ role: 'user', content });
          state.messages.push({ role: 'assistant', content: output });
        } else {
          const output = await sendNonStreaming(payload);
          appendMessage('ai', output);
          state.messages.push({ role: 'user', content });
          state.messages.push({ role: 'assistant', content: output });
        }
      } catch (err) {
        console.error(err);
        appendMessage('ai', `Error: ${err.message}`);
      } finally {
        setLoading(false);
      }
    }

    sendBtn.addEventListener('click', handleSend);
    promptEl.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        handleSend();
      }
    });

    clearBtn.addEventListener('click', () => {
      state.messages = [];
      chatEl.innerHTML = '';
      statusEl.textContent = 'InvestMate is ready · ask away';
      promptEl.value = '';
      promptEl.focus();
    });

    toggleStream.addEventListener('click', (e) => {
      e.preventDefault();
      STREAMING = !STREAMING;
      toggleStream.textContent = STREAMING ? 'Streaming: On' : 'Streaming: Off';
      toggleStream.dataset.on = String(STREAMING);
      toggleStream.setAttribute('aria-checked', STREAMING ? 'true' : 'false');
    });

    // Quiz functions

    function showQuiz(quizCard) {
      console.log('showQuiz called with:', quizCard);
      
      // Reset all quiz state
      currentQuiz = quizCard;
      currentQuestionIndex = 0;
      quizScore = 0;
      userAnswers = [];
      
      // Clear any previous quiz content
      const quizQuestionEl = document.getElementById('quizQuestion');
      const quizExplanationEl = document.getElementById('quizExplanation');
      if (quizQuestionEl) quizQuestionEl.innerHTML = '';
      if (quizExplanationEl) {
        quizExplanationEl.innerHTML = '';
        quizExplanationEl.style.display = 'none';
      }
      
      document.getElementById('quizTerm').textContent = `Topic: ${quizCard.term}`;
      document.getElementById('quizModal').classList.add('show');
      
      displayQuestion();
    }

    function displayQuestion() {
      if (!currentQuiz) {
        return;
      }
      
      if (currentQuestionIndex >= currentQuiz.questions.length) {
        console.log('All questions completed in displayQuestion, calling showQuizResults');
        // Don't call showQuizResults here, let nextQuestion handle it
        return;
      }

      const question = currentQuiz.questions[currentQuestionIndex];
      const questionEl = document.getElementById('quizQuestion');
      
      // Update progress
      document.getElementById('quizProgress').textContent = `Question ${currentQuestionIndex + 1} / ${currentQuiz.questions.length}`;
      document.getElementById('progressFill').style.width = `${((currentQuestionIndex + 1) / currentQuiz.questions.length) * 100}%`;
      document.getElementById('quizScore').textContent = `Score: ${quizScore}`;

      // Clear previous question
      questionEl.innerHTML = '';
      
      // Hide explanation
      const explanationEl = document.getElementById('quizExplanation');
      if (explanationEl) {
        explanationEl.style.display = 'none';
        explanationEl.innerHTML = '';
      }

      // Create question text
      const questionText = document.createElement('div');
      questionText.className = 'question-text';
      questionText.textContent = question.question;
      questionEl.appendChild(questionText);

      // Create options
      const optionsContainer = document.createElement('div');
      optionsContainer.className = 'question-options';

      // Debug: log question data
      console.log('Displaying question:', question);
      console.log('Question type:', question.type);
      console.log('Question options:', question.options);
      console.log('Has options:', !!question.options);
      console.log('Options length:', question.options ? question.options.length : 0);

      // Force remove options field for bool questions
      if (question.type === 'bool' && question.options) {
        console.log('WARNING: Bool question has options field, deleting it');
        delete question.options;
      }

      if (question.type === 'single' && question.options && question.options.length > 0) {
        // Multiple choice question
        question.options.forEach((option, index) => {
          const optionBtn = document.createElement('button');
          optionBtn.className = 'option-button';
          optionBtn.innerHTML = `
            <span class="option-label">${String.fromCharCode(65 + index)}</span>
            <span>${option}</span>
          `;
          optionBtn.addEventListener('click', () => selectOption(index, optionBtn));
          optionsContainer.appendChild(optionBtn);
        });
      } else if (question.type === 'bool') {
        // True/False question
        const trueBtn = document.createElement('button');
        trueBtn.className = 'option-button';
        trueBtn.innerHTML = '<span class="option-label">A</span><span>True</span>';
        trueBtn.addEventListener('click', () => selectOption(true, trueBtn));
        optionsContainer.appendChild(trueBtn);

        const falseBtn = document.createElement('button');
        falseBtn.className = 'option-button';
        falseBtn.innerHTML = '<span class="option-label">B</span><span>False</span>';
        falseBtn.addEventListener('click', () => selectOption(false, falseBtn));
        optionsContainer.appendChild(falseBtn);
      }

      questionEl.appendChild(optionsContainer);

      // Reset buttons
      document.getElementById('quizSubmit').disabled = true;
      document.getElementById('quizSubmit').style.display = 'inline-flex';
      document.getElementById('quizNext').style.display = 'none';
    }

    function selectOption(selectedValue, buttonElement) {
      // Remove previous selection
      document.querySelectorAll('.option-button').forEach(btn => {
        btn.classList.remove('selected');
      });

      // Mark current selection
      buttonElement.classList.add('selected');
      document.getElementById('quizSubmit').disabled = false;

      // Store the selection
      userAnswers[currentQuestionIndex] = selectedValue;
      
      // Auto-submit answer for immediate feedback
      submitAnswer();
    }

    function submitAnswer() {
      if (userAnswers[currentQuestionIndex] === undefined) return;

      const question = currentQuiz.questions[currentQuestionIndex];
      const userAnswer = userAnswers[currentQuestionIndex];
      const correctAnswer = question.answer;
      
      // Check if answer is correct
      const isCorrect = userAnswer === correctAnswer;
      if (isCorrect) {
        quizScore++;
      }

      // Show result
      showAnswerResult(question, userAnswer, correctAnswer, isCorrect);
    }

    function showAnswerResult(question, userAnswer, correctAnswer, isCorrect) {
      const options = document.querySelectorAll('.option-button');
      
      options.forEach((option, index) => {
        option.disabled = true;
        
        if (question.type === 'single') {
          if (index === correctAnswer) {
            option.classList.add('correct');
          } else if (index === userAnswer && !isCorrect) {
            option.classList.add('incorrect');
          }
        } else if (question.type === 'bool') {
          if ((index === 0 && correctAnswer === true) || (index === 1 && correctAnswer === false)) {
            option.classList.add('correct');
          } else if ((index === 0 && userAnswer === true && !isCorrect) || (index === 1 && userAnswer === false && !isCorrect)) {
            option.classList.add('incorrect');
          }
        }
      });

      // Show explanation
      const explanationEl = document.getElementById('quizExplanation');
      if (explanationEl) {
        console.log('Question object:', question);
        console.log('Explanation field:', question.explanation);
        
        // Get explanation text
        let explanationText = 'No explanation available';
        if (question.explanation) {
          explanationText = question.explanation;
        } else if (question.explanation === '') {
          explanationText = 'No explanation available';
        }
        
        explanationEl.innerHTML = `
          <div class="result-title">${isCorrect ? '✅ Correct!' : '❌ Incorrect'}</div>
          <div class="result-explanation">${explanationText}</div>
        `;
        explanationEl.style.display = 'block';
        
        console.log('Explanation text to display:', explanationText);
      } else {
        console.log('Explanation element not found');
      }

      // Update score
      document.getElementById('quizScore').textContent = `Score: ${quizScore}`;

      // Show next button
      document.getElementById('quizSubmit').style.display = 'none';
      if (currentQuestionIndex < currentQuiz.questions.length - 1) {
        document.getElementById('quizNext').style.display = 'inline-flex';
        document.getElementById('quizNext').textContent = 'Next Question';
      } else {
        document.getElementById('quizNext').style.display = 'inline-flex';
        document.getElementById('quizNext').textContent = 'View Results';
      }
    }

    function nextQuestion() {
      currentQuestionIndex++;
      console.log('Next question called, current index:', currentQuestionIndex, 'total questions:', currentQuiz.questions.length);
      if (currentQuestionIndex < currentQuiz.questions.length) {
        console.log('Moving to next question');
        displayQuestion();
      } else {
        console.log('All questions completed, showing quiz results');
        showQuizResults();
      }
    }

    function showQuizResults() {
      console.log('showQuizResults called');
      const totalQuestions = currentQuiz.questions.length;
      const percentage = Math.round((quizScore / totalQuestions) * 100);
      console.log('Quiz results:', { totalQuestions, quizScore, percentage });
      
      const questionEl = document.getElementById('quizQuestion');
      console.log('Question element found:', questionEl);
      
      if (!questionEl) {
        console.error('Quiz question element not found!');
        return;
      }
      
      // Clear any existing content
      questionEl.innerHTML = '';
      
      // Create results content
      const resultsDiv = document.createElement('div');
      resultsDiv.style.cssText = 'text-align: center; padding: 20px;';
      resultsDiv.innerHTML = `
        <h3 style="color: var(--text); margin-bottom: 16px;">🎉 Quiz Complete!</h3>
        <div style="font-size: 24px; font-weight: 700; color: ${percentage >= 70 ? '#22c55e' : percentage >= 50 ? '#f59e0b' : '#ef4444'}; margin-bottom: 16px;">
          ${quizScore} / ${totalQuestions} correct
        </div>
        <div style="font-size: 18px; color: var(--muted); margin-bottom: 20px;">
          Accuracy: ${percentage}%
        </div>
        <div style="font-size: 14px; color: var(--muted);">
          ${percentage >= 70 ? 'Excellent work—you understand this topic well.' : 
            percentage >= 50 ? 'Good job—keep practicing to build confidence.' : 
            'Consider reviewing the material to strengthen your understanding.'}
        </div>
      `;
      
      questionEl.appendChild(resultsDiv);

      document.getElementById('quizSubmit').style.display = 'none';
      document.getElementById('quizNext').style.display = 'none';
      document.getElementById('quizClose').textContent = 'Done';
      
      console.log('Quiz results displayed successfully');
      console.log('Final score:', quizScore, 'out of', totalQuestions);
    }

    function closeQuiz() {
      document.getElementById('quizModal').classList.remove('show');
      currentQuiz = null;
      currentQuestionIndex = 0;
      quizScore = 0;
      userAnswers = [];
    }

    // Quiz event listeners
    document.getElementById('quizSubmit').addEventListener('click', submitAnswer);
    document.getElementById('quizNext').addEventListener('click', nextQuestion);
    document.getElementById('quizClose').addEventListener('click', closeQuiz);
    
    // Global test function
    window.testQuizResults = function() {
      console.log('Testing quiz results display');
      if (currentQuiz) {
        showQuizResults();
      } else {
        console.log('No current quiz found');
      }
    };
    
    // Force complete quiz for testing
    window.forceCompleteQuiz = function() {
      console.log('Forcing quiz completion');
      currentQuestionIndex = currentQuiz.questions.length;
      showQuizResults();
    };

    // Close quiz when clicking outside
    document.getElementById('quizModal').addEventListener('click', (e) => {
      if (e.target.id === 'quizModal') {
        closeQuiz();
      }
    });

    // Page intro: let it play, then fade out & remove
    window.addEventListener('load', () => {
      const intro = document.getElementById('intro');
      if (!intro) return;
      setTimeout(() => {
        intro.classList.add('hide');
        setTimeout(() => intro.remove(), 1200); // match .intro.hide duration
      }, 900); // show overlay briefly before fading
    });
  </script>
  <!-- Quiz Modal -->
  <div id="quizModal" class="quiz-modal">
    <div class="quiz-content">
      <div class="quiz-header">
        <div class="quiz-title">
          📚 Finance Quiz
        </div>
        <button class="quiz-close" onclick="closeQuiz()">&times;</button>
      </div>
      
      <div class="quiz-progress">
        <span class="quiz-progress-text">Question <span id="quizCurrent">1</span>/<span id="quizTotal">3</span></span>
        <div class="quiz-progress-bar">
          <div class="quiz-progress-fill" id="quizProgressFill"></div>
        </div>
        <span class="quiz-score">Score: <span id="quizScore">0</span></span>
      </div>
      
      <div class="quiz-question" id="quizQuestion">
        <div class="quiz-question-text" id="quizQuestionText">Loading...</div>
        <div class="quiz-options" id="quizOptions"></div>
        <div class="quiz-result" id="quizResult"></div>
      </div>
      
      <div class="quiz-buttons">
        <button class="quiz-button secondary" onclick="closeQuiz()">Close</button>
        <button class="quiz-button primary" id="quizNext" onclick="nextQuestion()" style="display: none;">Next Question</button>
      </div>
    </div>
  </div>

  </body>
</html>